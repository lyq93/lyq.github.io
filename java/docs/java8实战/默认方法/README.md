## 默认方法

### 概述

> 默认方法是JAVA8提供的一个新特性，核心的功能就是对接口进行兼容性的扩展。
>
> 在接口中，使用default的关键字标识

### 默认方法出现后，接口与抽象的区别

> JAVA8之前，接口的方法是没有默认实现的，而抽象类是可以有普通实现的，在JAVA8之后，这个差异就不存在了。目前来说，接口与抽象类的区别主要体现在：
>
> - 接口不可以有实例字段来保存状态
> - 一个类只能继承一个抽象类，但是可以实现多个方法

### 默认方法的使用场景

- 可选方法

> 考虑有可能存在这样一种场景，一个类去实现一个接口，可能并不需要用到接口的所有方法，但是默认方法未出现之前（JAVA8之前），实现类还需要去额外的提供一个默认实现，这些都是无用代码。JAVA8之后，接口可以对上述的问题通过默认方法进行解决，消除了实现类的无用模版代码

- 行为的多继承

> JAVA只能继承单个类，却能实现多个接口。默认方法的出现，意味着给提供了多继承的能力。
>
> 可以通过精简接口，让实现类具备某些能力。
>
> 另外，通过让子类实现接口继承默认方法的方式，接口的方法迭代可以有效的控制所有的字类的行为。在这之前，需要每个子类去迭代自身的实现。

### 两个接口具有相同的方法签名，不同的行为，实现的行为是如何决定的？

#### 规则

- 类中方法优先级最高。类或父类声明的方法优先级高于接口的默认方法
- 如果第一条规则无法匹配，则子接口的优先级更高，即如果接口B继承了接口A，则B接口是子接口（最具体的实现）
- 如果依旧无法匹配，则需要显示的指明期望的调用方法

#### JAVA代码示例

> public interface A {
>
> ​	default void hello() {
>
> ​		System.out.println("hello from A");
>
> ​	}
>
> }
>
> public interface B extend A{
>
> ​	default void hello() {
>
> ​		System.out.println("hello from B")
>
> ​	}
>
> }
>
> public class C implements B,A {
>
> ​	public static void main(String... args) {
>
> ​		new C().hello(); //输出什么？
>
> ​	}
>
> }

> 应用解决冲突规则，因为类没有声明方法，所以第一条规则不适用。
>
> 第二条规则，子接口优先级更高，因为B接口继承自A接口，所以B接口比A接口更具体，所以会打印from B。
>
> 由此，如果B接口不继承A接口，那么这种情况下，第二条规则也不适用，两个接口之间不存在继承关系。那么就需要用到第三条规则，显示的生命调用哪个方法。
>
> JAVA8引入了一种新的语法X.super.m()，X就是你希望调用的父接口的，用在上述例子就是B.supper.hello()



### 菱形继承问题

> 简单描述，一个接口A有一个默认实现方法，接口B和接口C分别继承了接口A，类D实现了接口B和接口C，那么，如果类D调用了默认的实现方法，类D的行为是什么？
>
> 因为UML类继承图看起来是菱形，所以称为菱形继承问题

#### JAVA代码示例

> public interface A {
>
> ​	default void hello() {
>
> ​		System.out.println("hello from A");
>
> ​	}
>
> }
>
> public interface B extends A {};
>
> public interface C extends A {};
>
> public class D implements B,C {
>
> ​	public static void main(String... args) {
>
> ​		new D().hello(); // 打印什么	
>
> ​	}
>
> }

> 只会打印from A，实际上，只有一个接口声明了方法。
>
> - 如果在B接口增加一个方法签名相同的方法，那么根据第二规则，B接口比A接口更具体，所以会打印from B
> - 如果B、C接口都增加了方法签名相同的方法，那么根据第三条规则，就需要显示声明调用的方法
> - 如果C接口有一个不是默认方法的方法签名相同的方法，那么类D就需要显式的去实现该方法，那么就会打印from D

