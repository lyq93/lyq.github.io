## 表、栈和队列

### 抽象数据类型ADT

#### 概念

> 带有一组操作的一些对象的集合。像表、集合、图之类的带有一系列的操作的对象都可以看作是ADT，这就像是整数，实数、布尔数都是数据类型一样，都具有各自的相关操作，抽象数据类型也是如此。

#### 最基本的三种数据结构

- 表ADT

##### 概念

> 形如A0，A1，A2....An-1的一般的表，称这个表的大小是N，将大小为0的表称为空表。与表相关的操作集合，类似于find返回某一项出现的位置，insert、remove一般是从某个位置插入或者删除某个元素等等一系列的操作集合。一个ADT对象的功能怎样才算恰当，取决于程序设计者

##### 实现

- 数组实现

  - 时间效率

  > 对表的所有操作都可以通过使用数组来实现。数组的查找时间复杂度是常数时间，而插入和删除是O(n)。对这个结论进行解释就是，访问是通过下标直接定位到某一元素，这个是我们可以预期的。对于插入和删除，最坏的情况是从数据的第一位进行插入或者删除，称为前端插入/删除，这种情况下，需要把数组所有的数据往后移动一位或者往前移动一位，所以时间复杂度是O(n)。最好的情况下是永远在后端插入/删除，这样的时间复杂度是常数时间。

  - 场景

  > 经由数组实现的表有这样的特性，如果数组的插入操作都是高端插入、删除，随后只发生对数组的访问，这种场景下使用数组是一种恰当的实现。特别需要注意的是避免在前端插入或者删除的情况下使用数组实现。

  - 示例说明

  ```java
  public void makeList(List<Integer> list, int n) {
      for (int i = 0 ; i < n; i++) {
          list.add(i);
      }
  }
  ```

  > 这个示例的时间复杂度是O(n)，原因在于list.add是在数组的末端进行数据插入，这是一个常数时间级的操作，不存在数组元素的移动

  ```java
  public void makeList2(List<Integer> list, int n) {
      for (int i = 0; i < n; i++) {
          list.add(0, i);
      }
  }
  ```

  > 这个示例的时间复杂度是O(n2)，list.add是通过数组的前端进行数据插入操作，涉及到数组本身的元素的位置移动，所以这个操作是O(n)级的。

- 链表

  - 单链表

    > 为了避免数组的插入和删除的线性开销，需要保证表可以不连续的存储，否则表的每个部分都可能需要整体移动。链表由一系列节点组成，各个节点不需要在内存中相连，每个节点都包含一个表元素，一个到后一个元素的链，这个链称为next链，这是单链表的一个结构。

  - 双链表

    > 单链表的局限在于，如果需要删除最后一个节点，那么需要把最后节点的前一个节点的链修改为null，但是指向最后节点的链又没有提供前驱节点的信息，所以这个删除操作是比较复杂的。双链表的存在，就是解决这个问题，每一个节点，都拥有一个表元素，一个前驱链，一个后继链。双链表的这种结构在插入删除操作的时候只需要改变常量个元素的链即可，时间复杂度为O(1)。

  - 示例分析

    ```java
    public void makeList(List<Integer> list, int n) {
        for (int i = 0 ; i < n; i++) {
            list.add(i);
        }
    }
    ```

    > 这个示例对于数组或者链表来说，时间复杂度都是是O(n)，原因在于对于数组list.add是在表的末端进行数据插入，这是一个常数时间级的操作，不存在数组元素的移动。对于链表，插入操作就是常数级的操作。

    ```java
    public void makeList2(List<Integer> list, int n) {
        for (int i = 0; i < n; i++) {
            list.add(0, i);
        }
    }
    ```

    > 这个示例对于数组来说时间复杂度是O(n2)，list.add是通过数组的前端进行数据插入操作，涉及到数组本身的元素的位置移动，所以这个操作是O(n2)级的。对于链表来说，时间复杂度就是O(n)。

    ```java
    public int sum(List<Integer> list) {
        int total = 0;
        for (int i = 0; i < list.size(); i++) {
            total += list.get(i);
        }
        return total;
    }
    ```

    > 这个示例，对于数组来说，时间复杂度是O(n)，因为get属于常数级操作。对于链表来说，时间复杂度是O(n2)，因为get属于线性级操作。

- 栈

  - 概念

    > 栈是限制输入和输出都在一个位置上的表，该位置是指表的末端，也叫做栈的顶。对栈的操作有push和pop，push相当于是插入，pop相当于是删除。对空栈进行pop会抛出错误，但是如果栈空间满了，继续push这个时候并不会被判定为错误。栈又被称为后进先出表。

  - 栈的实现

    > 由于栈是一个规定输入和输出都在一个位置上的表，所以数组和链表都可以实现栈。
    >
    > 1、通过链表来实现的话，push相当于是在表的顶端插入数据，pop相当于是返回顶端的元素。
    >
    > 2、通过数组实现，与栈相关的操作是theArray和topOfStack，push相当于是topOfStack加一，然后theArray[topOfStafck] = x，pop相当于是使返回值等于theArray[topOfStack]，然后topOfStack减一。

  - 场景应用

    > 递归方法调用。当方法调用的时候，需要存储一些信息，比如方法的名称，返回的地址信息等等，这些信息可以抽象为存储在一张“纸”上。然后把这张纸放置在栈顶。然后控制转移到新的方法，新的方法也遵循相同的过程。到了方法返回时，根据栈顶的“纸”，复原所有的过程然后进行返回转移。这个就是使用一个栈就可以完成。

- 队列

  - 概念

    > 队列类似于栈，也都是表。使用队列的时候，插入在表的一端，删除在表的另外一端。

  - 队列的数组实现

    > 使用数组实现队列，需要保留一个数组theArray，以及front和back代表队列的两端，还需要一个currentSize表示队列中的个数。使一个元素x入队，即currentSize和back加一，然后theArray[back] = x，使一个元素出队，使返回值等于theArray[front]，然后front加一，currentSize减一。
    >
    > 从这里看出个问题就是，经过多次操作后，back是数组的最后一个下标，意味着队列满了。但其实不对的，因为若干个元素已经出队了，但是并没有调整back的位置导致的。
    >
    > 解决这个问题有一个简单的方法，就是循环数组。当front或者back加一导致超越了数组长度的时候，就将其重置到数组的开头。

    

