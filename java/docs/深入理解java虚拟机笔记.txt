1.Java虚拟机运行时的数据区域：
方法区：存放的是类信息，常量，静态变量等，所有线程共享。方法区里面的运行时常量池用于存放class文件的常量池内容
堆：存放的是对象及数组，所有线程共享
虚拟机栈：
每执行一个方法都会创建栈帧，用于存放局部变量表，操作数栈，动态链接，方法出口信息等。
方法的调用到结束就意味着栈帧的入栈到出栈。
局部变量表存放基本数据类型，对象引用，reference类型等。局部变量表所需的内存空间在编译时期就能完全确定，在运行时期并不会改变。
线程所请求的栈深度超过虚拟机所允许的深度，报StackOverflowError；如果虚拟机栈动态扩展的时候无法申请到足够的内存，报outOfMemoryError
线程私有。
本地方法栈：类似虚拟机栈，只是为本地方法服务。
程序计数器：因为cpu是来回切换执行线程的，程序计数器的作用就是记录线程执行的位置，当切回该线程时能继续执行。每一个线程都有一个程序计数器，线程私有 。

2.对象内存的分配
指针碰撞：
假设堆中内存是规整的（根据垃圾回收算法不同，有可能），有个指针作为空闲内存和已使用内存的分解指示器，那么给对象分配的内存的大小其实就是从已使用内存的点到空闲内存的该对象大小的距离。
空闲列表：
假设堆中的内存是散乱的（标记清除算法），那么虚拟机就必须维护一个列表，记录哪有内存是可用的，哪些内存是不可用的。然后找到一个够对象大小的内存分配给该对象，并更新列表。

内存分配的安全性问题：
堆是共享的，那么就可能存在多个线程同时分配的情况，若是一块内存在分配之后线程在修改指针的同时另一个线程又用了该块内存即有问题。这时有2种解决方案，同步保证更新操作的原子性或者在堆内存中给每个线程分配一个各自的本地线程分配缓冲（TLAB），各自线程在各自线程内存上分配，只有当TLAB分配完之后才需要同步处理。

3.对象的内存布局
对象在内存中存储的布局分为3块：
对象头：
存储对象自身运行时数据（哈希码，GC分代年龄，锁状态标志，线程持有的锁等）
存储类型指针（指向该对象的类元数据，即虚拟机通过该指针确定该对象是哪个类的实例）
实例数据：存储的是真正有效信息（对象的字段内容等）。这部分的存储顺序是受虚拟机分配策略和Java源码中字段的定义顺序有关，满足该前提下，父变量会排在子变量之前，但如果开启了compactFields，子类变量就有可能出现在父类变量之前（较窄的子类变量会插入到父类变量的空隙之中）。
对齐填充：这部分本身没有实际意义，但是虚拟机规定对象大小必须是8字节的整数倍，而因为对象头刚好是8字节的整数倍，所以当实例数据不是8字节的整数倍时，需要通过该部分来实现补全。

4.对象的访问定位
操作对象是用存储在局部变量表中的reference来执行，虚拟机规定reference类型存放的是一个对象的引用，并没有规定该引用需要以何种方式去定位且访问对象，所以不同的虚拟机实现，访问方式有可能不同。目前主流是2种：
句柄：reference存放的是句柄地址，堆中给出一块内存作为句柄池，句柄存放的是实例数据指针和对象类型指针。使用对象就是通过reference找到句柄，句柄找到实例数据。所以当实例数据发生移动时，reference不需要改变，只需要改变句柄的实例数据指针即可。
直接指针：reference存放的是对象地址。使用对象就是通过reference直接操作对象。所以直接指针的访问方式的速度更快。

5.判断对象是否存在的算法
引用计数算法：当有一个地方引用该对象的时候，计数器+1，当失去一个引用的时候，计数器-1，当计数器的值为0的时候，表示对象不可能再被使用，即可以回收。该算法的缺点在于当对象相互引用的时候，计数器的值不为0，但两个对象已经不会再被使用，却无法回收。
可达性分析算法：通过GC roots为节点，一级一级的往下搜索，当一个对象到GC roots没有可达的引用链时，对象不可达，即可回收。针对上述引用计数算法的缺点来说，即使对象相互引用，必然从roots节点出发，当该两个对象没其他引用时，必然到达不了roots，所以可以解决上一中算法的问题。

6.可以作为GCroots的对象
虚拟机栈（栈帧的局部变量表）中引用的对象
方法区的静态属性引用的对象
方法区中常量引用的对象
本地方法栈中引用的对象

7.引用概念
强引用：程序代码中普遍存在的，类似于String s = new String();只要强引用存在，对象就不可能会被回收。
软引用：描述一些还有用但并非必须的对象。当系统内存要溢出之前，会把软引用对象给回收。
弱引用：比软引用更弱一些，只存在于下一次垃圾回收之前，不管内存足不足够，都会被回收。
虚引用：最弱的一种引用，该引用的存在与否并不影响对象的回收，唯一的作用在于对象回收之后会收到一个系统通知。

8.回收对象的具体细节
对象的回收会经历2次标记过程，第一次当发现对象没有与GCroots有相连引用链时，对象被标记。然后判断该对象是否有必要执行finalize方法，当对象没有覆盖finalize方法或者finalize方法已经被虚拟机调用过，则判断为没有必要执行。但当判断为有必要执行时，对象被放置在一个F-queue的一个队列中，并会在稍后由虚拟机创建的一个低优先级的finalize线程去执行它。然后GC会对队列中的所有对象进行检查，如果发现在第二次检查中有对象有了可达引用链，就移除队列，否则标记第二次，然后对象就被真正回收。

9.垃圾收集算法
标记-清除：（1）效率不高（2）产生不连续的内存碎片
复制：解决效率问题，但要把内存一分为二（在商业虚拟机中，这种算法使用得比较多。新生代的对象多数是朝生夕死的，不一定非要把内存划分为1比1，而可以划分为8比1，然后依赖分配担保保证安全性。适合用于新生代）
标记-整理：复制算法在老年代的高存活率的情况下，效率不高。

10.垃圾收集器
概念：
单线程（单个线程执行回收工作且用户线程必须停止）
多线程包括并行（多个垃圾回收线程同时工作，用户线程停止）；并发（垃圾回收线程和用户线程同时进行）

serial收集器：
单线程收集器，不仅只会用一条线程去做垃圾收集，还在收集的时候把用户线程全部暂停。
优点就是简单而高效，适合用在client模式下的虚拟机

parNew收集器（新生代收集器）：
相当于是serial的多线程版，只是并行收集还不是并发收集，并且该收集器可以与CMS收集器配合工作。

parallel scavenge收集器（新生代收集器）：
并行的多线程收集器，与parNew类似，但不同在于该收集器关注的点是吞吐量而不是用户线程的停顿时间。
吞吐量：执行用户代码时间/执行用户代码时间+垃圾收集时间
停顿时间越短就越适合与用户交互的程序，高吞吐量即高效的利用cpu，适合用于后台运算

serial old收集器：
单线程收集器的老年代版本，可作为cms的后备方案

parallel old收集器：
由于存在parallel scavenge注重吞吐量的新生代收集器，如果选择该收集器，那么老年代的收集器的选择就只有serial old收集器，由于serial old在服务端的不足，吞吐量未必能达到可观的效果，所以出了这个也以吞吐量为目标的老年代收集器，可以搭配使用。

CMS收集器运行步骤：
（1）初始标记（停止用户线程）
（2）并发标记
（3）重新标记（停止用户线程）
（4）并发清除
CMS收集器的缺点：
（1）对CPU资源非常敏感（CMS的默认回收线程数：（CPU数量+3）/4，当CPU越来越多的时候，回收占用的线程数就越多）
（2）对浮动垃圾无法处理
（3）CMS基于标记-清除算法，会产生不连续的内存空间

11.内存分配和回收策略
（1）对象优先分配于Eden区
（2）大对象可以直接分配于老年代
（3）长时间存活的对象进入老年代（对象拥有对象年龄计数器，每经历一次GC不死，年龄+1，达到一定年龄进入老年代）

G1收集器：
特点：
并行与并发
分代收集（G1不需要与其他收集器配合即可管理整个GC堆，但它能够根据不同的方式去处理新创建的对象和已经存活了一段时间的对象）
空间整合（与CMS不同，从整体看G1是标记整理，但从局部的region看，是基于复制的，也就是说不会产生不连续的内存空间）
可预测停顿（比之CMS的另一大优点，建立可预测的停顿时间模型，能让使用者指定在一个长度为M的时间片段内，消耗在垃圾收集的时间不超过N）

使用G1收集器时，java堆的内存布局与其他收集器不同，它将java堆划分为多个region（区域）。之所以可以建立可预测停顿，也是因为这些独立的region，G1跟踪各个region的垃圾收集性价比，维护这样一个优先级列表，然后根据给定的收集时间优先去收集高性价比的region。

11.1空间分配担保：
在进行新生代GC的时候，会去判断老年代可用空间时候大于新生代所有对象的空间，如果大于，则此次的新生代GC是安全的。如果不大于，那么查看是否设置了允许担保失败，如果是允许的，那么就判断老年代的可用内存是否大于历次的晋升的对象的平均大小。如果大于，那么就进行不安全的新生代GC（所谓不安全是指GC之后的对象的大小是无法知道的，有可能会大于老年代的内存，此时会发生担保失败从而触发full GC），如果是小于的话，就直接进行full GC。

12.调优案例：
高性能硬件的调优
（1）使用大内存的JDK（对GC频率要控制得好）
缺点：1.大内存导致的GC停顿时间过长 2.大内存导致的转出快照过大，无法解析 3.相同程序的64位JDK一般比32位的JDK消耗内存大
（2）32位的逻辑集群（请求分发）

集群间同步调优：
缺点：1.全局资源竞争 2.部分资源无法高校利用

什么是class文件：以8字节为基础单位的二进制流（各个数据项严格按照顺序排列，没有空隙，没有分隔符，全部都是程序运行所需数据）

13.class文件存储的数据类型：
（1）无符号数（基本数据类型）：描述数字，索引引用，数量值，字符串值等。
（2）表（复合数据类型）：有层次关系的复合数据类型。

14.class文件的内容：
（1）魔数：class文件的头4个字节为魔数，用于确定该class文件是否为一个能被虚拟机接受的class文件（身份识别）。
（2）版本号：接着魔数后面的是版本号，前2个字节是次版本号，后2个字节是主板本号。版本号决定了该class文件能否被当前版本的虚拟机所运行。
（3）常量池（相当于是资源仓库）：常量池入口是个2字节的常量池容量计数值（用于表示该常量池有多少数据项，索引从1开始而不是0，目的在于用0表示不引用常量池中的数据项）
（4）访问标志：2字节的访问标志用于描述类或者接口的信息（是否为public，abstarct，被声明为final等）
（5）类索引，父类索引和接口索引集合：该三项确定类的继承关系
（6）字段表：用于描述接口或类中声明的变量。对字段的信息进行描述，会引用常量池中的字段描述符。
（7）方发表：对方法的信息进行描述，会引用常量池中的字段描述符。
...

15.常量池存放内容：
字面量：java语言层面的常量概念（字符串，常量等）
符号引用：
（1）类和接口的全限定名
（2）字段的名称和描述符
（3）方法的名称和描述符

16.虚拟机浮点转整数的运算指令：向零取整（最接近但是不大于原值的整数）

17.类加载的时机
（1）加载
（2）验证
（3）准备
（4）解析
（5）初始化
（6）使用
（7）卸载

18.必须立即对类进行初始化的5种场景
（1）new对象，获取静态字段，调用静态方法
（2）使用反射
（3）初始化类的时候其父类还没有初始化
（4）虚拟机启动时，用户指定的执行主类
（5）动态语言

19.类加载过程的加载阶段所执行的操作：
（1）通过类的全限定名获取类的二进制字节流
（2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
（3）再内存中创建一个java.lang.class对象，作为方法区的各项数据的访问入口

20.验证阶段
（1）文件格式验证（验证字节流是否符合虚拟机Class文件的规范）
（2）元数据验证（对类的元数据信息进行语义校验，保证其符合java规范）
（3）字节码验证（对方法体的校验，方法的执行是否是正常的）
（4）符号引用验证（确保解析能正常执行，符号引用是否都是正常的）

21.准备阶段
为类变量分配内存空间并初始化（初始化为系统初始化，并不是源码的程序给定的数值初始化）

22.解析阶段
将常量池的符号引用转化为直接引用

23.初始化
对类变量进行程序赋值的初始化

24.类加载器
（1）启动类加载器
（2）扩展类加载器
（3）应用程序加载器

25.双亲委派模型
加载器需要加载类的时候委托上一层的加载器进行加载，直到找到最顶层的加载器对该类进行加载。该模型的好处在于程序的稳定。原因是因为2个类是否相等的前提是同一个加载器加载的情况下才有比较的价值，不同加载器加载的同一个类，是不想等的。

26.编译过程泛指
（1）java源代码编译成class文件的前端编译
（2）class文件到机器码的后端编译
（3）java源代码到机器码的静态编译

27.java源代码到class文件的编译过程
（1）解析与填充符号表
词法分析：将源码中的字符转换为编译过程的标记（编译过程的最小单元）
语法分析：生成抽象语法树
填充符号表：根据语法书填充符号表（符号表类似kv对）
（2）插入式注解处理器的注解处理过程
jdk1.6以后提供的api，可以对抽象语法树进行读取，修改，添加操作。修改过语法树则回到步骤1
（3）分析和生成字节码
语义分析：标注检查（常量折叠概念）和数据控制流分析（对方法内部逻辑进行验证）
解语法糖：泛型擦除，自动装箱，拆箱，变长参数等

27.jit编译器的功能：
将热点代码编译成与平台机器相关的机器码，并进行优化处理。

28.热点探测主流方式：
（1）基于采样的热点探测：查看线程栈顶的方法，经常出现则为热点方法。
优点：简单，高效，还可获取调用关系。
缺点：很难精确确认方法的热度
（2）基于计数器的热点探测：给每个方法计数器（方法调用计数器（方法调用计数器热度的衰减和半衰周期）和回边计数器），超过阀值就会触发jit

29.优化技术
（1）公共子表达式消除（出现过的表达式在再出现的时没发生任何变化即可引用之前计算的）
（2）数组范围检查消除
（3）方法内联（消除调用成本）
（4）逃逸分析（对象在方法中被定义，又被外部方法调用则为方法逃逸；被外部线程访问到为线程逃逸。如果确认对象不会出现方法逃逸和线程逃逸，可以做栈上分配，同步消除，标量替换）

30.栈上分配，同步消除，标量替换
（1）栈上分配
对象没有方法逃逸意味着随着栈帧的消失而消失，那么可以把对象分配在栈里而不是堆中，减轻垃圾收集的压力。
（2）同步消除
如果对象没有线程逃逸，那么读写就不会有竞争，那么就可以消除同步措施。
（3）标量替换
如果一个对象不存在方法逃逸，而且可以再分，那么就把对象拆分为被引用到的成员变量等直接栈上分配。