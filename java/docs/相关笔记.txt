《Effective Java》

1.静态工厂方法与构造器的优劣
（1）静态工厂方法有名称，代码更易于阅读与使用
（2）静态工厂方法可以防止对象无休止的创建
（3）静态工厂方法可以返回类型的子类型

2.多个构造器参数时，考虑用构建器
静态工厂方法和构造器处理多参数问题时都比较麻烦。这个时候可以考虑使用构建器模式（builder模式），即给类一个内部类，内部类拥有外部类的字段，如果是外部类的必填字段，就在内部类的构造器里面赋值，然后其他字段作为内部类里面的方法进行分别赋值。然后内部类再提供一个返回外部类对象的方法，该方法调用外部类的私有构造器来拿到外部类的对象。而外部类的私有构造器参数为内部类对象，这样就能通过传入的内部类对象去给外部类的字段赋值，然后返回给客户端使用。

使用方法：new一个外部类对象.内部类构造器.内部类方法.内部类方法...

3.确保类成为不可变
1.不要提供任何改变类对象状态的方法。
2.保证类不会被扩展
3.使所有的域都是final的
4.使所有的域都是私有的
5.如果类具有指向可变对象的域，确保客户端不会拿到指向该域的引用。

不可变类的作用：可以作为工厂，把频繁被请求的对象保存起来，当现有的实例符合请求时，就不需要去重新创建对象。

4.构造器绝不能调用可被覆盖的方法。
假设父类的构造器调用了被子类覆盖的方法，而子类的该方法输出子类的一个域的值，而该域的值是在子类的构造器中初始化的。当new子类构造器的时候，父类的构造器先调用，然后调用父类构造器里面的子类方法，然后输出子类的域的值，这个时候子类的构造器还未被调用即域还没被赋值，程序运行的结果就是不正确的。

5.嵌套类
（1）静态成员类
方法外，不依赖于外部类实例而独立存在。
（2）非静态成员类
方法外，每个实例都有指向外部实例的引用。
（3）匿名类
方法内，有类型说明该类的特征。
（4）局部类
方法内，无类型说明该类特征。

6.开始线程的start方法和run方法有什么区别
以在main方法里面来说，start方法会开启一个新线程，而不是使用main线程，即如果有两个线程对象，他们会独立工作而不各自影响。而run方法的话，不会开启一个新的线程，而是使用main线程，即如果有两个线程对象，第二个线程对象只能等第一个线程对象执行完之后才能执行。

7.线程池的两种提交任务的方式
（1）pool.excute()，该方式传入runnable对象，该对象的run方法是没有返回结果的。
（2）pool.submit()，该方式传入callable对象，该对象的call方法是有返回值的，返回值根据传入的泛型类型决定，需要注意的一点返回值是通过future对象接收的。然后调用get方法拿到线程的返回值。当子线程执行未结束时，主线程调用get方法会发生阻塞。

8.BlockingQueue（并发包消息队列）常用的两种实现方式：
（1）ArrayBlockingQueue，底层数据结构是数组的数据结构，长度是固定的。
（2）LinkedBlockingQueue,LinkedList的底层数据结构，链式。长度是可以不固定的。

区别：数据结构不同，导致LinkedBlockingQueue的吞吐量要比ArrayBlockingQueue大，但是在线程数多的情况下，它的性能可预见性要比ArrayBlockingQueue低。

9.java反射机制
场景：很多情况下，我们并不知道要具体new哪一个对象，例如传递过来的参数是一个读配置文件得到的类的全限命名，然后要根据这个拿到该类的对象。

具体的实现：
public class xx = class.forname("")拿到类
xx.newInstance()拿到该类的对象，另外还有一些其他方法可以拿到类的接口，构造器，方法，字段等
同时也能够拿到私有的构造器，方法，字段。调用accessible方法，取消权限检测即可。

10.同步阻塞I/O：
客户端与服务端建立soket流通信，客户端这边通过outputStream写信息过去，服务端读取。然后客户端在关闭流之前也在读取服务端的响应。这样的话，即使客户端这边不再写了，服务端那边还在一直等待读取信息而不会写响应到输出流。这样就导致了同步阻塞I/O

11.传统I/O与NIO的区别：
传统I/O：传统I/O的速度比NIO要快，但是传统I/O的问题在于服务器的性能。传统I/O会有2个严重阻塞的地方，第一个是接受客户端请求的时候（网络问题），有可能请求会很长时间才建立成功，而传统I/O接受请求又是阻塞式的。第二个是用流读数据和写数据的时候，如果数据很大，读写的时间很长也会导致阻塞。而且传统I/O在每拿到一个请求的时候都会new一个线程去处理，如果请求量很大，服务器的资源消耗就很大，加之上述的2个阻塞问题，提供线程池的方式也不能根本解决问题。线程不能及时处理任务回归线程池，请求无法得到响应也是不行的。

NIO：是提供一种轮询的方式去查看请求是否建立成功，读写数据是否完成，只有当监测到成功状态的时候才进行处理。这样就不会导致阻塞问题。也就实现了非阻塞I/O

12.spring机制：
加载spring得到对象的两种方式：一个是在spring配置文件中配置bean，一个是使用spring注解扫描包得到对象（compenent）。
自定义注解：自定义注解其实就是一个java文件，代码
@Target({ ElementType.TYPE })//注解用在接口上
@Retention(RetentionPolicy.RUNTIME)//VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息
@Component
public @interface RpcService {
 
    String value();
}
然后就可以在我们的业务类里面加自己的自定义注解。

13.如何防止反射攻击（调用accessble方法访问私有构造器创建对象）：
在私有构造器中判断对象是否已经创建。具体方法是用一个私有final的对象去接收构造器的创建的对象，然后在私有构造器中判断对象是否已经存在。

14.避免对象的重复创建：
（1）静态工厂方法代替构造器
（2）如果能够确定对象创建之后不可变，可以定义为static（保证内存只有一份），final

15.消除过期引用：
内存泄露：
（1）栈（栈先增长后缩减，存在过期引用，由于栈是自己管理内存，所以不会被回收）
（2）缓存（写入缓存的对象容易被遗忘就永久待在缓存中）
（3）监听和回调（客户端注册回调，没有显示的取消回调）

16.遇到的java模式总结：
（1）builder模式
场景：一个类的字段过多，且有必填字段，选填字段，例如药物类，药的组成
实现：静态工厂方法和构造器处理多参数问题时都比较麻烦。给类一个内部类，内部类拥有外部类的字段，如果是外部类的必填字段，就在内部类的构造器里面赋值，然后其他字段作为内部类里面的方法进行分别赋值。然后内部类再提供一个返回外部类对象的方法，该方法调用外部类的私有构造器来拿到外部类的对象。而外部类的私有构造器参数为内部类对象，这样就能通过传入的内部类对象去给外部类的字段赋值，然后返回给客户端使用。
代码：
public class Medicine{
	private String num;
	private String dayTimes;
	private String reson;

	public builder{
		private String num;
		private String dayTimes;
		private String reson;
		
		public builder(String num,String dayTimes){
			this.num = num;
			this.dayTimes = dayTimes;
		}
		public reson(String reson){
			this.reson = reson;
		}

		public Medicine builder(){
			return new medicine(this);
		}
		
	}

	private medicine(Builder builder){
		this.num = builder.num;
		this.dayTimes = builder.dayTimes;
		this.reson = builder.reson;	
	}
}
（2）：decorator模式（装饰模式）
（1）场景：解决继承带来的问题（1.子类继承父类，扩展新的方法。当父类新增方法的时候如果同子类新方法重名，导致编译报错（签名相同返回类型不同的情况下）或覆盖超类方法（签名和返回类型一致）），注意decorator模式不适用于回调框架。
（2）实现：引进一个新类，新类引用现有类的一个实例，调用现有类的方法，返回他的结果。新类的方法即完成转发功能。好处在于不依赖于现有类的实现细节，即使现有类添加了新的方法，也不会影响到新类。
（3）代码：
//接口
public interface A{
	public int add(){
	
	}
}

//转发类转发接口方法，方法实现满足最为基本的功能要求（通用功能）
public class forwardA implement A{
	private final A a;
	public forwardA(A a){
		this.a = a;
	}	

	public int add(){
		return a.add();		
	}
}

public class improveA extends forwardA{
	private int count = 0;
	public improveA(A a){
		super(a);
	}
	//重写方法（扩展方法）
	public int add(){
		count++;
		return super.add();//父类的方法（实现接口的类）是满足基础功能的方法
	}
	//额外功能
	public int getCount(){
		return this.count;
	}
}
(3)策略模式
场景：比如出行去一个城市，那么可以有多种选择，汽车，火车，高铁，飞机，这几个出行的策略都应该是一个方法，如果写在一个类里面会导致类庞大难以维护。策略模式就是组织算法，让程序结构更加灵活，具有更好的维护性与扩展性
实现：拿上述例子来说，定义一个旅行的接口，接口包含一个出行方式的方法。定义一个抽象类实现该接口拿到所有的策略，然后编写子类去继承抽象类实现各自具体的策略。最后提供一个环境类，环境类持有接口所代表的对象，然后返回策略执行的结果。
代码：
//接口
public interface travle{
	public void travle(){
	
	}
}

//抽象类实现接口，拿到所有的策略
public abstrac class abstracTravle implements travle{
	public void travle(){

	}
}
//具体策略的实现
public class car extends abstracTravle{
	@override
	public void travle(){
		System.out.print("take car for travle");
	}
}
//具体策略的实现
public class train extends abstracTravle{
	@override
	public void travle(){
		System.out.print("take train for travle");
	}
}
//环境类，持有接口引用的对象
public class contextTravle{
	private final travle travel;
	
	public contextTravel(travle travle){
		this.travel = travle;
	}

	public void forTravle(){
		travle.travle();
	}
}

17.对于骨架实现类的理解：
（1）骨架实现类把接口的功能拆分得更加细致。接口只定义类型，骨架实现类去实现相关功能。实现类继承自骨架实现类，这样做的好处在于实现类只要专注于自身需要提供的方法而忽略接口中不需要的方法。
（2）提供骨架实现类，能保证在接口需要发生改变的时候（一般不可能）导致的损害范围降低。那些继承自骨架实现类的实现类是不会有影响的，只是没有新加方法的功能。但是那些直接实现该接口的实现类就会编译报错。

18.List和list<Object>有什么区别：
List是原生态类型，是list<String>的父类型，可以接受list<String>不会编译报错，而list<Object>不是list<String>的父类型，接受list<String>会编译报错。
代码：
该代码会在编译时期发现错误。
public class Hello{
    public static void main(String[] args){
       List<String> list = new ArrayList<String>();
       add(list,new Integer(52));
       String s = list.get(0);
       System.out.println(s);
   }
    
   public static void add(List<Object> list,Object object){
	   list.add(object);
   }
}

该代码不会在编译时期发现错误，直至运行时期会发生ClassCastException
public class Hello{
    public static void main(String[] args){
       List<String> list = new ArrayList<String>();
       add(list,new Integer(52));
       String s = list.get(0);
       System.out.println(s);
   }
    
   public static void add(List list,Object object){
	   list.add(object);
   }
}

结论：
原生态类型是不安全的，泛型是安全的。

19.如何理解有限制通配符<? extends E>及<? super E>
利用栈类的例子来说，E代表类的参数。调用push的时候，是往栈里面存放元素，那么元素就应该小于等于栈类所限制的类型。调用pop的时候，是消费该栈类的元素，那么消费者必须大于等于该类存放的类型。所以即有PESC

20.异构容器
异构容器是类型安全且异构（key是不同的类型）的。具体代码实现：
public class Hello{
	Map<Class<?>,Object> map = new HashMap<Class<?>,Object>();
    public <T> void setMap(Class<T> type,T instance){
    	if(type==null){
    		System.out.println(type + "is null");
    		return;
    	}
    	map.put(type, type.cast(instance));
    };
    public <T> T getMap(Class<T> type){
    	return type.cast(map.get(type));
    };
    
    public static void main(String[] args) {
		Hello h = new Hello();
		h.setMap(String.class, "lyq");
		h.setMap(Integer.class, 93);
		h.setMap(Class.class, Hello.class);
		
		String s = h.getMap(String.class);
		Integer i = h.getMap(Integer.class);
		Class<?> h1 =  h.getMap(Class.class);
		System.out.println(s);
		System.out.println(i);
		System.out.println(h1.getName());
		
	}
}

该类的内部实现是一个Map，key是class，可以是各种不同的class，所以是异构的。之所以是类型安全的是指，请求值的时候，请求哪个Class，就会返回那个Class对应的实例值，绝不会返回其他的Class实例。另外还可以结合有限制通配符来使用。

21.简述枚举
枚举的使用场景是知道一组固定常量的情况下。当一种常量对应一种行为的时候，考虑使用特定常量方法（枚举里的所有常量都必须实现枚举类里面的抽象方法），当多个常量共享同一行为的时候，考虑使用策略枚举（写一个内部枚举类）。注意：使用switch模式的缺点在于，新增加一个常量，容易忘记在switch里面增加条件，编译并不会报错，但是运行结果是错误。

22.方法参数的有效性检查和保护性拷贝：
对于任意的方法都应该进行参数的有效性检查（检查参数是否满足方法的约束条件，比如是否为null等），这样做的目的是为了在运行出错的时候在出错点就能抛出相应的异常来提供快速的问题查找。
对于的方法的任意可变参数都应该进行保护性拷贝，可变参数意味着恶意客户端的攻击通道。有效性检查应该针对保护性拷贝之后的对象。

23.慎用重载
public class test{
	public static String getString(Set<?> set){
		return "set"
	}
	public static String getString(List<?> list){
		return "list"
	}
	public static String getString(Collection<?> col){
		return "unknown Collection"
	}

	main{
		Collection<?>[] collections = {
			new HashSet<String>(),
			new ArrayList<Integer>(),
			new HashMap<String,Integer>()
		}
		for(Collection c : collections){
			test.getString(c);
		}
	}
}
上述代码打印的值为3次unknown Collection。重载是在编译时期就决定了调用哪个重载方法。解决方案是可以使用同一个方法进行instanceof判断返回相应的值或者重载的方法必须拥有类型不同的一个参数才能使用重载。重写（覆盖）是在运行时期决定调用子类还是父类的方法。

24.慎用可变参数
可变参数提供了方法的灵活性，但是会在每次调用的时候进行数组的分配和初始化（性能）。如果一个方法具有多个参数，假设95%的调用都会使用《=n个参数，那么就重载n个该方法，每个方法参数+1，最后超过n的参数的方法使用可变参数数组。这样，会调用到可变参数数组的方法只有5%的可能。既保证了方法的灵活性又保证了性能。

25.mysql相关知识：
（1）and优先级大于or
（2）in的执行速度比or快
（3）通配符%表示任意字符（0，1，多个），搜索模式%x%，x，zx，xz都能被检索到
（4）通配符_表示仅且匹配一个字符，搜索模式_x，zx能匹配到，zzx不能被匹配到
（5）通配符的搜索速度比一般操作符慢，当且仅当通配符在搜索模式开头时最慢，相当于全表扫描。
（6）正则表达式： .表示匹配任意一个字符；| 表示or；[123]表示1或2或3；^在集合[]中表示取反，在匹配串中表示开头；-表示范围（[0-9]表示任意数字）；*表示0个或多个；+表示1个或多个；？表示0个或1个；{n}表示指定数目的匹配；
REGEXP '.000'
REGEXP '[123] Ton'
REGEXP '[0-5] Ton'
REGEXP '\\([0-9] sticks?\\)'
REGEXP '[[0-9]]{4}'
REGEXP '^[0-9\\.]'
(7)like和正则表达式的差别：
like不使用通配符的话，相当于=，而REGEXP是匹配列中的值。比如一个列是xx1000，like "1000"是不会有返回值的，但是REGEXP '1000'则是有返回值的。 
(8)视图：
视图其实就是一张虚拟的表（由复杂的sql执行出来的结果集所构成）。作用就是简化我们的sql代码。
(9)存储过程：
存储过程其实就是一组mysql的语句集合。之所以要使用存储过程是因为存储过程把复杂的执行步骤封装在一个原子单元里面避免了出错的概率。存储过程的执行要比单条单条的sql的执行的速度要快。简而言之的话，使用存储过程的好处就是简单，安全，性能！
(10)游标：
(11)触发器：
触发器针对update，insect，delete对表的操作进行事件的触发，一个表的触发器是6个（各种操作的前后时间段）。update语句可以拿到new虚拟表，能够拿到更新的值。delete能够拿到old虚拟表，能够拿到旧值做备份。

26.Linux不使用私库yum需要配置的2个地方：
1.IP需要配置GATEWAY和DNS（测试ping ww.baidu.com 

，确认虚拟机能上网下载依赖包）
2.配置nameserver(vi /etc/resolv.conf,设置为虚拟机网关IP即可)
3.测试(yum update)

27.启动hadoop相关问题
（1）jps查看namenode没有的话，考虑配置有问题
（2）格式化namenode会有个默认的路径（/tmp）下，如果配置的路径不起效，配置名有问题
（3）启动datanode能用jps查看到datanode，但是页面没有相关节点，后台日志报错如下：
2017-08-29 07:46:49,761 INFO org.apache.hadoop.hdfs.server.datanode.DataNode: Block pool BP-244925840-192.168.144.98-1503932264048 (Datanode Uuid null) service to /192.168.144.98:9000 beginning handshake with NN
2017-08-29 07:46:49,767 ERROR org.apache.hadoop.hdfs.server.datanode.DataNode: Initialization failed for Block pool BP-244925840-192.168.144.98-1503932264048 (Datanode Uuid null) service to /192.168.144.98:9000 Datanode denied communication with namenode because hostname cannot be resolved (ip=192.168.144.97, hostname=192.168.144.97): DatanodeRegistration(0.0.0.0, datanodeUuid=90ad10c6-0ad6-4b0b-b843-592324659f38, infoPort=50075, ipcPort=50020, storageInfo=lv=-56;cid=CID-d54ee884-0726-487f-8b11-959f5d0617cd;nsid=2067138966;c=0)
该问题是没使用hostname而使用ip导致的。只需要在namenode的hdfs-site.xml中加入如下配置：
<property>
     <name>dfs.namenode.datanode.registration.ip-hostname-check</name>
     <value>false</value>
</property>
（4）使用hadoopAPI上传文件
<1>环境准备
1.拿到linux下编译好的hadoop.tar.gz，解压后行程hadoop文件夹，然后配置环境变量该文件夹的HADOOP_HOME和PATH路径。
2.由于该tar是在linux下编译的，现在使用的是Windows运行，所以缺少一些东西。需要拿到Windows下编译的项目里的bin文件夹和lib文件夹，替换linux下的该2个目录。
3.新建工程，把hadoop下的common和hdfs包给引入进来，然后正式编写API
<2>运行时发生的错误：
1.上传文件时报路径下的文件不存在（注意是否已经隐藏了文件的后缀，导致文件名不正确的问题）
2.上传文件时报从本地到服务器的连接失败（注意namenode是否启动）

（5）向hdfs读取数据流程
首先客户端向nameNode发送一个读取数据的请求，然后nameNode根据自身存储的元数据信息找到对应的数据（N个副本，每个文件的M个block）所在的dataNode信息返回给客户端，然后客户端挑选一台dataNode建立socket流，然后dataNode开始发送数据（从磁盘读取，放入流中，以packet为单位做校验），然后本地接收数据，先写缓存，再写入目标文件。
（6）向hdfs写数据流程
首先请求nameNode上传文件，nameNode查询文件是否存在，目录是否已经存在。然后返回是否可以上传。然后客户端再请求第一个block该上传到哪些dataNode上，然后nameNode根据算法（选一台最近，一台最远，然后随机）选出N（N为配置的储存文件的副本数）个dataNode返回给客户端。客户端请求其中一台dataNode上传数据（假设为A），dataNode之间会建立pipeline，客户端每个block以packet为单位上传，A收到packet会传给B，然后传给C，同时放入一个应答队列等待应该，当传完所有dataNode之后响应给客户端，客户端再接着传入一个packet
（7）nameNode的工作机制
nameNode功能主要有两点，一是响应客户端请求，二是对元数据的管理。主要分析下对于元数据的管理。首先元数据是要放入到内存中去的，这就是避免硬盘的读取速度过慢问题。然后提供一个镜像文件对内存数据进行拷贝（提供宕机的数据还原能力），但这份镜像文件并不是完整的一个内存数据文件，然后再提供一个操作日志文件记录hdfs的操作，当需要还原的时候就可以根据镜像文件+操作日志的方式还原出最新的内存数据。然后再提供一个secondary_name去定期的拿到镜像文件和操作日志文件进行合并放到自身中。当nameNode故障时，secondary_name就可以根据保存的自身的元数据来恢复namenode的元数据
（8）javaAPI的流式读取数据
（9）离线日志采集工作机制及shell脚本

为什么需要使用Hadoop而不用关系型数据库？
寻址时间的提升远不及传输速率的提升；即硬盘的读写操作导致的延迟肯定是要慢于硬盘的带宽导致的传输速率的延迟

为什么Hadoop写数据时如果目录存在会报错？
Hadoop写数据到hdfs上可能会存在长时间写入的问题，如果在写入未结束时又发起一次同样目录的写入可能会导致数据丢失问题。

combiner函数的作用？
减少map端到reduce端的数据传送量。每个map端产生的数据取其最值即可过滤掉无效数据，可节省数据流量。

namenode的容错方案？
（1）备份元数据文件到磁盘和远程挂载的文件系统
（2）运行辅助的namenode，具体实现如（7）

hadoop的高可用？
使用2台服务器作为活动namenode和备用namenode，datanode给namenode发送的数据需要发给2台机器，然后都写到内存当中去。另外编辑日志的问题，可采用共享和群体日志管理的2种方式，推荐使用群体日志管理的方式（当活动namenode假死的情况下，2台机器有可能都同时往共享的编辑日志写数据）。群体日志管理等于是写多份数据到多份日志文件种，即使丢失一份也不会造成影响。这样子的话，当活动namenode发生故障时，备用namenode可以瞬间接管服务。如果不是这种方式，那么单点故障到备用服务启动接管服务的这段时间是没办法提供服务的。冷启动需要处理的方面有：1.需要将镜像文件写到内存种；2.需要将编辑日志重演；3.服务器的启动时间

hadoop写数据的原理？
写数据到hdfs上的时候，会产生一个数据管道，管道里面是我们配置的复本数量个的datanode，另外还有一个确认管道用于响应是否一个数据包成功传送完成。如果当某一个datanode中途发生故障，处理的原理是先把数据管道的所有数据放回到管道前端（如此做的目的是保障下游的节点不会遗漏数据包），然后把正确的节点所得到的数据包做一个标识，传送给namenode（记录传输偏移量，当故障datanode恢复后，需要删除垃圾数据），然后把故障datanode删掉，继续写入数据。当写入完成后，namenode会发现复本数量不够，会新起一个节点，然后把数据写入。