## java
* [1.并发编程线程基础](#1)
* [1.1什么是线程](#1.1)
* [1.2线程创建与运行的方式](#1.2)
* [1.3线程停止的方式](#1.3)
* [1.4线程死锁](#1.4)
* [1.5ThreadLocal](#1.5)
* [2.并发编程的其他基础知识](#2)
* [2.1Java中共享变量的内存可见性问题](#2.1)



<h2 id="1">1.并发编程线程基础</h2>
  <h3 id="1.1">1.1什么是线程？</h3><br>
线程是进程中的一个实体，是进程的更细粒度的一个执行单元。进程是一次程序的运行过程，一个进程中至少有一个线程。一个进程中的所有线程共享进程的堆和方法区的资源，每个线程也有自己的私有程序计数器和栈空间。<br>
  <h3 id="1.2">1.2.线程创建与运行的方式？</h3><br>
  Java中有3种线程创建方式，分别为继承Thread类，实现Runnable接口，使用FutureTask方式。继承Thread类的缺点在于灵活性，其一java是单继承的，限制了类的扩展，其二线程与代码之间没有分离，一个线程类对应一套代码。而使用实现Runnable接口的方式，其一避免了继承的局限，其二线程与代码解耦，可以通过传参的方式让不同线程对同一套代码有不同的实现。以上两种方式的缺点在于没有返回值，使用FutureTask方式的话，可以通过获取线程执行结果判断线程执行的状态。

[代码实现](./code/java并发编程之美/线程创建的方式)
  <h3 id="1.3">1.3.线程停止的方式？</h3><br>
  使线程停止的方式：<br>
  （1）wait():当一个线程调用wait方法的时候，线程会被阻塞挂起，直到有其他线程调用了notify()方法或者notifyAll()方法才会被重新唤起进入就绪状态。<br>
  （2）sleep():当一个线程调用了sleep()方法，线程会让出cpu执行时间，进入休眠状态，但是不会释放锁。<br>
  wait方法和sleep方法的区别在于：<br>
  1.对于锁的控制：线程在调用了wait方法后会释放掉锁，但是sleep方法不会。<br>
  2.方法所属类不同：wait方法是属于Object类的方法，而sleep方法是属于Thread类的方法。<br>
  <h3 id="1.4">1.4.线程死锁</h3><br>
  (1)什么是线程死锁<br>
  举例来说，假设有线程A，B，资源C，D。线程A持有资源C并请求资源D，线程B持有资源D并请求资源C。这导致两个线程互相持有对方需要的资源这种情况就是线程死锁。<br>
  (2)产生死锁的条件<br>
  1.互斥条件：线程持有的资源具有排他性<br>
  2.请求并持有：线程持有至少一个资源并请求另外线程持有的某个资源<br>
  3.不可剥夺条件：线程持有的资源在线程执行完毕之前不会释放<br>
  4.环路等待条件：发生死锁的情况下必然形成线程-资源的环形链<br>
  <h3 id="1.5">1.5.ThreadLocal</h3><br>
  (1)ThreadLocal的使用样例<br>
  
[ThreadLocal代码样例](./code/java并发编程之美/ThreadLocalDemo) <br>
  (2)ThreadLocal的实现原理<br>
  ThreadLocal类调用set方法的时候，会把值写入到Thread类的变量threadLocals中，调用get方法的时候会从Thread类的threadLocals中把数据再读取出来。所以只要调用线程不结束，那么通过ThreadLocal类存入的数据就不会消失，除非调用了remove方法。threadLocals是个map结构，也就意味着一个线程可以关联多个ThreadLocal变量。
<h2 id="2">2.并发编程线程基础</h2>
  <h3 id="2.1">2.1.Java中共享变量的内存可见性问题</h3>
  (1)Java的内存模型<br>
    java内存模型规定所有的变量都存放在主存当中，每个线程需要使用变量的时候从主存中读取到自己的工作内存当中。线程读写操作的是自己工作内存中的变量。举个例子，假如现在有个双核cpu，且有cpu私有的一级缓存，所有cpu共享的二级缓存。那么假设有线程A和线程B，分别在不同的CPU上执行，而且操作同一个共享变量。那么线程A可能会进行如下操作，从主存中读取共享变量到二级缓存和一级缓存，然后修改变量的值，写回到一级缓存和二级缓存并刷新到主存。线程B读取共享变量的时候，一级缓存没有命中，二级缓存命中了，这时候取得的值是线程A修改过后的值，然后线程B对该值进行修改，然后写回一级缓存，二级缓存和主存。这个时候问题来了，线程A需要再次修改该共享变量，一级缓存命中返回的是线程B修改之前的数据，这就是共享变量的内存可见性问题。<br>
  (2)共享变量的内存可见性问题的解决<br>
  其一，通过加锁可以解决，但是使用锁的方式较为笨重，会带来线程的上下文切换。其二使用volatile关键字，该关键字确保共享变量对所有线程可见，共享变量被volatile关键字修饰之后，线程操作完共享变量会同步到主存中，其他线程读取被volatile关键字修饰的共享变量会从主存中读取而不是自己的工作内存。
