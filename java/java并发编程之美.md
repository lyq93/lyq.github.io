## java
* [1.并发编程线程基础](#1)
* [1.1什么是线程](#1.1)
* [1.2线程创建与运行的方式](#1.2)
* [1.3线程停止的方式](#1.3)
* [1.4线程死锁](#1.4)
* [1.5ThreadLocal](#1.5)



<h2 id="1">1.并发编程线程基础</h2>
  <h3 id="1.1">1.1什么是线程？</h3><br>
线程是进程中的一个实体，是进程的更细粒度的一个执行单元。进程是一次程序的运行过程，一个进程中至少有一个线程。一个进程中的所有线程共享进程的堆和方法区的资源，每个线程也有自己的私有程序计数器和栈空间。<br>
  <h3 id="1.2">1.2.线程创建与运行的方式？</h3><br>
  Java中有3种线程创建方式，分别为继承Thread类，实现Runnable接口，使用FutureTask方式。继承Thread类的缺点在于灵活性，其一java是单继承的，限制了类的扩展，其二线程与代码之间没有分离，一个线程类对应一套代码。而使用实现Runnable接口的方式，其一避免了继承的局限，其二线程与代码解耦，可以通过传参的方式让不同线程对同一套代码有不同的实现。以上两种方式的缺点在于没有返回值，使用FutureTask方式的话，可以通过获取线程执行结果判断线程执行的状态。

[代码实现](./code/java并发编程之美/线程创建的方式)
  <h3 id="1.3">1.3.线程停止的方式？</h3><br>
  使线程停止的方式：<br>
  （1）wait():当一个线程调用wait方法的时候，线程会被阻塞挂起，直到有其他线程调用了notify()方法或者notifyAll()方法才会被重新唤起进入就绪状态。<br>
  （2）sleep():当一个线程调用了sleep()方法，线程会让出cpu执行时间，进入休眠状态，但是不会释放锁。<br>
  wait方法和sleep方法的区别在于：<br>
  1.对于锁的控制：线程在调用了wait方法后会释放掉锁，但是sleep方法不会。<br>
  2.方法所属类不同：wait方法是属于Object类的方法，而sleep方法是属于Thread类的方法。<br>
  <h3 id="1.4">1.4.线程死锁</h3><br>
  (1)什么是线程死锁<br>
  举例来说，假设有线程A，B，资源C，D。线程A持有资源C并请求资源D，线程B持有资源D并请求资源C。这导致两个线程互相持有对方需要的资源这种情况就是线程死锁。<br>
  (2)产生死锁的条件<br>
  1.互斥条件：线程持有的资源具有排他性<br>
  2.请求并持有：线程持有至少一个资源并请求另外线程持有的某个资源<br>
  3.不可剥夺条件：线程持有的资源在线程执行完毕之前不会释放<br>
  4.环路等待条件：发生死锁的情况下必然形成线程-资源的环形链<br>
  <h3 id="1.5">1.5.ThreadLocal</h3><br>
  
