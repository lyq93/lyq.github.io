## java
* [1.shell相关知识点](#1)
* [1.1shell运行方式](#1.1)
* [1.2shell变量与字符串](#1.2)
* [1.3线程停止的方式](#1.3)
* [1.4线程死锁](#1.4)
* [1.5ThreadLocal](#1.5)
* [2.并发编程的其他基础知识](#2)
* [2.1Java中共享变量的内存可见性问题](#2.1)
* [2.2指令重排序](#2.2)
* [2.3几种锁的介绍](#2.2)


<h2 id="1">1.shell相关知识点</h2>
  <h3 id="1.1">1.1shell运行方式</h3><br>
1、作为可执行程序，例如shell脚本文件名是test.sh，使用./test.sh的方式可以运行脚本。不能直接输入文件名运行的原因是：文件名运行系统会到PATH路径中寻找该脚本，一般情况下，脚本是没有放在PATH路径目录中的，所以需要加上./表示在当前的目录中运行脚本<br>
2、作为解释器参数，这种方式是直接运行解释器，脚本作为参数传入，例如/bin/sh test.sh<br>
  <h3 id="1.2">1.2.shell变量与字符串</h3><br>
  1、shell变量类型：<br>
  （1）局部变量：shell脚本内定义的变量，只在当前shell实例中有效，其他shell程序无法访问。<br>
  （2）环境变量：所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。<br>
  （3）shell变量：shell变量是由shell脚本设置的特殊变量，保证shell的正常运行。<br>
  2、字符串：<br>
  （1）单引号字符串的限制：单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。<br>
  （2）双引号字符串的优势：双引号里可以有变量；双引号里可以出现转义字符<br>
  <h3 id="1.3">1.3.线程停止的方式？</h3><br>
  使线程停止的方式：<br>
  （1）wait():当一个线程调用wait方法的时候，线程会被阻塞挂起，直到有其他线程调用了notify()方法或者notifyAll()方法才会被重新唤起进入就绪状态。<br>
  （2）sleep():当一个线程调用了sleep()方法，线程会让出cpu执行时间，进入休眠状态，但是不会释放锁。<br>
  wait方法和sleep方法的区别在于：<br>
  1.对于锁的控制：线程在调用了wait方法后会释放掉锁，但是sleep方法不会。<br>
  2.方法所属类不同：wait方法是属于Object类的方法，而sleep方法是属于Thread类的方法。<br>
  <h3 id="1.4">1.4.线程死锁</h3><br>
  (1)什么是线程死锁<br>
  举例来说，假设有线程A，B，资源C，D。线程A持有资源C并请求资源D，线程B持有资源D并请求资源C。这导致两个线程互相持有对方需要的资源这种情况就是线程死锁。<br>
  (2)产生死锁的条件<br>
  1.互斥条件：线程持有的资源具有排他性<br>
  2.请求并持有：线程持有至少一个资源并请求另外线程持有的某个资源<br>
  3.不可剥夺条件：线程持有的资源在线程执行完毕之前不会释放<br>
  4.环路等待条件：发生死锁的情况下必然形成线程-资源的环形链<br>
  <h3 id="1.5">1.5.ThreadLocal</h3><br>
  (1)ThreadLocal的使用样例<br>
  
[ThreadLocal代码样例](./code/java并发编程之美/ThreadLocalDemo) <br>
  (2)ThreadLocal的实现原理<br>
  ThreadLocal类调用set方法的时候，会把值写入到Thread类的变量threadLocals中，调用get方法的时候会从Thread类的threadLocals中把数据再读取出来。所以只要调用线程不结束，那么通过ThreadLocal类存入的数据就不会消失，除非调用了remove方法。threadLocals是个map结构，也就意味着一个线程可以关联多个ThreadLocal变量。
<h2 id="2">2.并发编程线程基础</h2>
  <h3 id="2.1">2.1.Java中共享变量的内存可见性问题</h3>
  (1)Java的内存模型<br>
    java内存模型规定所有的变量都存放在主存当中，每个线程需要使用变量的时候从主存中读取到自己的工作内存当中。线程读写操作的是自己工作内存中的变量。举个例子，假如现在有个双核cpu，且有cpu私有的一级缓存，所有cpu共享的二级缓存。那么假设有线程A和线程B，分别在不同的CPU上执行，而且操作同一个共享变量。那么线程A可能会进行如下操作，从主存中读取共享变量到二级缓存和一级缓存，然后修改变量的值，写回到一级缓存和二级缓存并刷新到主存。线程B读取共享变量的时候，一级缓存没有命中，二级缓存命中了，这时候取得的值是线程A修改过后的值，然后线程B对该值进行修改，然后写回一级缓存，二级缓存和主存。这个时候问题来了，线程A需要再次修改该共享变量，一级缓存命中返回的是线程B修改之前的数据，这就是共享变量的内存可见性问题。<br>
  (2)共享变量的内存可见性问题的解决<br>
  其一，通过加锁可以解决，但是使用锁的方式较为笨重，会带来线程的上下文切换。其二使用volatile关键字，该关键字确保共享变量对所有线程可见，共享变量被volatile关键字修饰之后，线程操作完共享变量会同步到主存中，其他线程读取被volatile关键字修饰的共享变量会从主存中读取而不是自己的工作内存。但是需要注意的一点是，volatile关键字只保证可见性，不保证原子性。
  <h3 id="2.2">2.2.指令重排序</h3>
  Java内存模型允许编译器和处理器对指令重排序以提升性能。重排序只会对不存在数据依赖关系的指令进行重排。在单线程情况下，重排序不会有问题，但是在多线程情况下就可能会产生执行结果跟预期结果不一致的情况。
  <h3 id="2.3">2.3.几种锁的介绍</h3>
  （1）乐观锁与悲观锁<br>
  乐观锁：认为数据在一般情况下不会产生冲突，所以在访问记录前不会施加排他锁，而是在进行数据提交的时候对记录进行校验。<br>
  悲观锁：认为数据在一般情况下都会产生冲突，所以在访问记录前会施加排他锁，在整个数据处理过程中不会对锁进行释放。<br>
  （2）公平锁与非公平锁<br>
  公平锁：对于在等待锁的线程来说，获取释放锁的机制是哪个线程先请求锁资源由哪个线程先获取到锁。<br>
  非公平锁：对于在等待的线程来说，获取释放锁的机制是随机的。<br>
  （3）独占锁与共享锁<br>
  独占锁：任何时候锁都只由一个线程获得，属于悲观锁。<br>
  共享锁：锁可以由多个线程共享使用，属于乐观锁。<br>
  （4）可重入锁与自旋锁<br>
  可重入锁：一个线程如果可以获取自己持有的锁，这种锁称为可重入锁。<br>
  自旋锁：一个线程去获取锁的时候，如果没有获取到，在还没有放弃CPU使用权的情况下，会不断的尝试去获取锁。这样做的目的是为了防止线程上下文切换带来的性能开销。<br>
