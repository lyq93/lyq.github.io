## java
* [1.shell相关知识点](#1)
* [1.1shell运行方式](#1.1)
* [1.2shell变量与字符串](#1.2)
* [1.3数组](#1.3)
* [1.4shell脚本参数](#1.4)
* [1.5shell运算符](#1.5)
* [2.并发编程的其他基础知识](#2)
* [2.1Java中共享变量的内存可见性问题](#2.1)
* [2.2指令重排序](#2.2)
* [2.3几种锁的介绍](#2.2)


<h2 id="1">1.shell相关知识点</h2>
  <h3 id="1.1">1.1shell运行方式</h3><br>
1、作为可执行程序，例如shell脚本文件名是test.sh，使用./test.sh的方式可以运行脚本。不能直接输入文件名运行的原因是：文件名运行系统会到PATH路径中寻找该脚本，一般情况下，脚本是没有放在PATH路径目录中的，所以需要加上./表示在当前的目录中运行脚本<br>
2、作为解释器参数，这种方式是直接运行解释器，脚本作为参数传入，例如/bin/sh test.sh<br>
  <h3 id="1.2">1.2.shell变量与字符串</h3><br>
  1、shell变量类型：<br>
  （1）局部变量：shell脚本内定义的变量，只在当前shell实例中有效，其他shell程序无法访问。<br>
  （2）环境变量：所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。<br>
  （3）shell变量：shell变量是由shell脚本设置的特殊变量，保证shell的正常运行。<br>
  2、字符串：<br>
  （1）单引号字符串的限制：单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。<br>
  （2）双引号字符串的优势：双引号里可以有变量；双引号里可以出现转义字符<br>
  （3）获取字符串长度：echo ${#string}<br>
  （4）获取子字符串：echo ${string:1:4}<br>
  （5）查找子字符串i或者o的位置：echo `expr index "$string" io`<br>
  <h3 id="1.3">1.3.数组</h3><br>
  bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。<br>
  数组的定义：array_name=(value0 value1 value2 value3)<br>
  数组的获取：valuen=${array_name[n]}；使用 @ 符号可以获取数组中的所有元素，例如echo ${array_name[@]}<br>
  数组长度：<br>
  获取数组的元素个数：length=${#array_name[*]}或者length=${#array_name[@]};<br>
  获取数组单个元素的长度：length=${#array_name[n]}<br>
  <h3 id="1.4">1.4.shell脚本的参数</h3><br>
  (1)特殊字符对参数的处理<br>
  $#: 输出参数的个数；<br>
  $*: 输出所有参数拼接后的一个字符串；<br>
  $@: 输出所有参数，每个参数都用双号包起来<br>
  $$: 输出当前进程的id号；<br>
  $?: 输出最后一个命令的状态，0是正常，其他值是出现错误；<br>
  $!: 输出运行的最后一个进程的id号；<br>
  <h3 id="1.5">1.5.shell运算符</h3><br>
  (1)算术运算符<br>
  1、加法：+ `expr $a + $b`；<br>
  2、减法：- `expr $a - $b`；<br>
  3、乘法：* `expr $a \* $b`； 在mac中不需要转义<br>
  4、除法：/ `expr $b / $a`；<br>
  5、取余：% `expr $b % $a`；<br>
  6、赋值：= a=$b<br>
  7、相等：== [ $a == $b ]<br>
  8、不相等 != [ $a != $b ]<br>
  (2)关系运算符<br>
  1、相等：-eq [ $a -eq $b ]；<br>
  2、不相等：-ne [ $a -ne $b ]；<br>
  3、大于：-gt [ $a -gt $b ]；<br>
  4、小于：-lt [ $a -lt $b ]；<br>
  5、大于等于：-ge [ $a -ge $b ]；<br>
  6、小于等于：-le [ $a -le $b ]；<br>
  (3)布尔运算符<br>
  1、非运算符：！ [ !false ] true；<br>
  2、或运算符：-o [ $a -lt 20 -o $b -gt 100 ]；<br>
  3、与运算符：-a [ $a -lt 20 -a $b -gt 100 ]；<br>
  (4)逻辑运算符<br>
  1、逻辑的and：&& [[ $a -lt 100 && $b -gt 100 ]]；<br>
  2、逻辑的or：|| [[ $a -lt 100 || $b -gt 100 ]]；<br>
  (5)字符串运算符<br>
  1、相等：= [ $a = $b ]；<br>
  2、不相等：!= [ $a != $b ]；<br>
  3、检查字符串长度是否为0：-z [ -z$a ]；为0返回true<br>
  4、检查字符串长度是否不为0：-n [ -n$a ]；不为0返回true<br>
  5、检查字符串是否为空：$ [ $a ]；不为空返回true<br>
  (6)文件测试运算符<br>
  1、检测文件是否是块设备文件：-b [ -b $file ]；<br>
  2、检测文件是否是字符设备文件：-c [ -c $file ]；<br>
  3、检测文件是否是目录：-d [ -d $file ]； 在mac中不需要转义<br>
  4、检测文件是否设置了SGID位：-g [ -g $file ]；<br>
  5、检测文件是否设置了粘着位：-k [ -k $file ]；<br>
  6、检测文件是否可读：-r [ -r $file ]<br>
  7、检测文件是否可写：-w [ -w $file ]<br>
  8、检测文件是否可执行 -x [ -x $file ]<br>
  9、检测文件是否位空（文件大小大于0） -s [ -s $file ]<br>
  10、检测文件（包括目录）是否存在 -e [ -e $file ]<br>
<h2 id="2">2.并发编程线程基础</h2>
  <h3 id="2.1">2.1.Java中共享变量的内存可见性问题</h3>
  (1)Java的内存模型<br>
    java内存模型规定所有的变量都存放在主存当中，每个线程需要使用变量的时候从主存中读取到自己的工作内存当中。线程读写操作的是自己工作内存中的变量。举个例子，假如现在有个双核cpu，且有cpu私有的一级缓存，所有cpu共享的二级缓存。那么假设有线程A和线程B，分别在不同的CPU上执行，而且操作同一个共享变量。那么线程A可能会进行如下操作，从主存中读取共享变量到二级缓存和一级缓存，然后修改变量的值，写回到一级缓存和二级缓存并刷新到主存。线程B读取共享变量的时候，一级缓存没有命中，二级缓存命中了，这时候取得的值是线程A修改过后的值，然后线程B对该值进行修改，然后写回一级缓存，二级缓存和主存。这个时候问题来了，线程A需要再次修改该共享变量，一级缓存命中返回的是线程B修改之前的数据，这就是共享变量的内存可见性问题。<br>
  (2)共享变量的内存可见性问题的解决<br>
  其一，通过加锁可以解决，但是使用锁的方式较为笨重，会带来线程的上下文切换。其二使用volatile关键字，该关键字确保共享变量对所有线程可见，共享变量被volatile关键字修饰之后，线程操作完共享变量会同步到主存中，其他线程读取被volatile关键字修饰的共享变量会从主存中读取而不是自己的工作内存。但是需要注意的一点是，volatile关键字只保证可见性，不保证原子性。
  <h3 id="2.2">2.2.指令重排序</h3>
  Java内存模型允许编译器和处理器对指令重排序以提升性能。重排序只会对不存在数据依赖关系的指令进行重排。在单线程情况下，重排序不会有问题，但是在多线程情况下就可能会产生执行结果跟预期结果不一致的情况。
  <h3 id="2.3">2.3.几种锁的介绍</h3>
  （1）乐观锁与悲观锁<br>
  乐观锁：认为数据在一般情况下不会产生冲突，所以在访问记录前不会施加排他锁，而是在进行数据提交的时候对记录进行校验。<br>
  悲观锁：认为数据在一般情况下都会产生冲突，所以在访问记录前会施加排他锁，在整个数据处理过程中不会对锁进行释放。<br>
  （2）公平锁与非公平锁<br>
  公平锁：对于在等待锁的线程来说，获取释放锁的机制是哪个线程先请求锁资源由哪个线程先获取到锁。<br>
  非公平锁：对于在等待的线程来说，获取释放锁的机制是随机的。<br>
  （3）独占锁与共享锁<br>
  独占锁：任何时候锁都只由一个线程获得，属于悲观锁。<br>
  共享锁：锁可以由多个线程共享使用，属于乐观锁。<br>
  （4）可重入锁与自旋锁<br>
  可重入锁：一个线程如果可以获取自己持有的锁，这种锁称为可重入锁。<br>
  自旋锁：一个线程去获取锁的时候，如果没有获取到，在还没有放弃CPU使用权的情况下，会不断的尝试去获取锁。这样做的目的是为了防止线程上下文切换带来的性能开销。<br>
