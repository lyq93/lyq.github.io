## java
* [1.JVM基础原理](#1)
* [1.1什么是JVM](#1.1)
* [1.2JVM运行时区域](#1.2)
* [1.3对象的创建过程](#1.3)
* [1.4对象分配方式](#1.4)
* [1.5对象访问方式](#1.5)
* [1.6对象回收方式](#1.6)
* [1.7对象在内存中的存储结构](#1.7)
* [2.垃圾收集基础](#2)
* [2.1垃圾收集算法](#2.1)
* [2.2垃圾收集器](#2.2)
* [3.JVM其他知识](#3)
* [3.1类加载机制](#3.1)
* [3.2必须进行类初始化的几种场景](#3.2)
* [3.3判断类是否是无用类的条件](#3.3)
* [3.4类加载器](#3.4)
* [3.5双亲委派模型](#3.4)



<h2 id="1">1.JVM基础原理</h2>
  <h3 id="1.1">1.1什么是JVM？</h3><br>
JVM是执行JAVA编译生成的.class文件的容器。所谓的JAVA语言特点的跨平台性，就是因为JVM在不同系统上执行.class能产生相同的结果。并且JVM执行.class文件是编译与解释共存的。解释执行是常态，编译是针对热点代码<br>
  <h3 id="1.2">1.2.JVM运行时区域</h3><br>
  （1）堆：存储对象的一块内存区域。线程共享<br>
  （2）栈：存放局部变量表，对象引用等信息，线程私有。<br>
  （3）方法区：存放类信息及常量信息（常量池），线程共享。<br>
  （4）本地方法栈：类同于栈，只是为本地方法服务。
  （5）程序计数器：CPU分片执行，当线程上下文切换的时候，线程能正确回到上次执行的位置就是由程序计数器来提供的功能，线程私有。<br>
  <h3 id="1.3">1.3.对象的创建过程</h3><br>
  （1）类加载检查：当JVM遇到new关键字的时候，会先去检查该对象的属于的类是否加载，如果没有先进行类加载过程，否则执行第二步。<br>
  （2）对象分配：为对象分配内存空间，分配方式有两种，在后续会进行阐述。<br>
  （3）设置对象头：把对象的元信息保存到对象头中，包括对象的分代年龄，hashCode，所属类信息等等。<br>
  （4）初始化：为对象进行系统初始化，成员变量进行零值初始化。<br>
  （5）程序初始化：按程序员的意愿进行初始化。<br>
  <h3 id="1.4">1.4.对象的分配方式</h3><br>
  （1）指针碰撞：从已分配内存的边界移动对象大小的距离的内存进行对象的分配。这种方式基于内存是规整的情况，内存的规整与否又取决于垃圾回收器采用的回收算法。<br>
  （2）空闲列表：从内存中挑选一块未使用的且满足分配对象的区域进行对象分配。这种方式基于内存是散乱的情况。<br>
  <h3 id="1.5">1.5.对象的访问方式</h3><br>
  （1）直接指针：对象的引用存在于栈空间的局部变量表的refence变量中，通过该变量经过一次寻址就可以定位到对象。这种方式的好处在于快速，但对象地址发生变化的时候需要去栈空间修改refence变量。<br>
  （2）句柄：在内存中开辟一块内存作为句柄池，对象的引用存在于句柄池中，refence变量存句柄池的地址。对象的访问通过二次寻址完成。这种方式因为需要二次寻址，所以速度会相较于第一种方式慢，但优点是refence变量不需要修改。<br>
  <h3 id="1.6">1.6.对象的回收方式</h3><br>
  （1）引用计数：对象持有一个引用，计数就加一，当计数为零时认为对象可以被回收。这种方式的缺陷在于两个对象的相互引用，导致计数不为零，但实质上这两个对象都是可回收对象。<br>
  （2）可达性分析：从GCroot对象开始，往下进行遍历。凡是不可达的对象，皆是可回收对象。<br>
  <h3 id="1.7">1.7.对象在内存中的存储结构</h3><br>
  （1）对象头：对象头存放的是对象的分代年龄，hashCode，类信息等等。<br>
  （2）实例数据：对象真正的数据，包括字段内容等等。<br>
  （3）对齐填充：JVM规定对象存于内存中必须是8字节的整数倍。该部分对对象的大小进行符合JVM规范的内容填充。<br>
  <h2 id="2">2.垃圾收集基础</h2>
  <h3 id="2.1">2.1垃圾收集算法</h3><br>
  （1）标记-清除：对内存空间内的可回收对象进行标记，然后通过垃圾收集线程进行回收。这种方式的问题在于效率不高以及会产生不连续的内存空间。<br>
  （2）复制：把内存一分为二，一块空间进行对象回收，剩余对象复制到另一块未使用的内存空间。这种方式解决了标记-清除的问题，清除后的内存是规整的。但是当内存中存活对象的几率比较大的时候，复制算法的效率不高。<br>
  （3）标记-整理：该方式和标记-清除差不多，区别在于对象回收之后会对内存进行一个规整操作，使内存是规整的。<br>
  （4）分代垃圾收集：不同的垃圾收集算法适用于不同的场景，例如复制适用于存活对象率较低的情况下。所以JVM把内存划分为新生代和老年代，新生代对象朝生夕死，适合用复制算法进行垃圾回收。老年代对象存活率高，适合于标记清除或者标记整理。<br>
  <h3 id="2.2">2.2垃圾收集器</h3><br>
  （1）serial收集器：单线程收集器，不仅只会用一条线程去做垃圾收集，还在收集的时候把用户线程全部暂停。优点就是简单而高效，适合用在client模式下的虚拟机。<br>
  （2）parNew收集器（新生代收集器）：相当于是serial的多线程版，只是并行收集还不是并发收集，并且该收集器可以与CMS收集器配合工作。<br>
  （3）parallel scavenge收集器（新生代收集器）：并行的多线程收集器，与parNew类似，但不同在于该收集器关注的点是吞吐量而不是用户线程的停顿时间。吞吐量：执行用户代码时间/执行用户代码时间+垃圾收集时间，停顿时间越短就越适合与用户交互的程序，高吞吐量即高效的利用cpu，适合用于后台运算<br>
  （4）serial old收集器：单线程收集器的老年代版本，可作为cms的后备方案<br>
  （5）parallel old收集器：由于存在parallel scavenge注重吞吐量的新生代收集器，如果选择该收集器，那么老年代的收集器的选择就只有serial old收集器，由于serial old在服务端的不足，吞吐量未必能达到可观的效果，所以出了这个也以吞吐量为目标的老年代收集器，可以搭配使用。<br>
  （6）CMS收集器：一款并发收集器，用户线程和垃圾回收线程同时工作。<br>
 回收步骤：<br>
（1）初始标记（停止用户线程）：初步标记与GCroot相连的对象<br>
（2）并发标记：通过可达性分析对内存中所有可回收对象进行标记，此时用户线程也正常执行<br>
（3）重新标记（停止用户线程）：由于第二步用户线程执行会产生新的可回收对象，所以这一步对新产生的可回收对象进行标记<br>
（4）并发清除：进行垃圾回收操作，此时用户线程也是正常执行的<br>
缺点：<br>
（1）对CPU资源非常敏感（CMS的默认回收线程数：（CPU数量+3）/4，当CPU越来越多的时候，回收占用的线程数就越多）<br>
（2）对浮动垃圾无法处理<br>
（3）CMS基于标记-清除算法，会产生不连续的内存空间<br>
（7）G1收集器：<br>
（1）分代收集（G1不需要与其他收集器配合即可管理整个GC堆，但它能够根据不同的方式去处理新创建的对象和已经存活了一段时间的对象）<br>
（2）空间整合（与CMS不同，从整体看G1是标记整理，但从局部的region看，是基于复制的，也就是说不会产生不连续的内存空间）<br>
（3）可预测停顿（比之CMS的另一大优点，建立可预测的停顿时间模型，能让使用者指定在一个长度为M的时间片段内，消耗在垃圾收集的时间不超过N）<br>
  <h2 id="3">3.JVM其他知识</h2>
  <h3 id="3.1">3.1类加载机制</h3><br>
  （1）加载：通过类的全限定名找到类的二进制字节流，把二进制字节流转换为方法区的运行时数据结构，生成java.lang.class对象作为方法区数据的访问入口<br>
  （2）验证：验证.class文件是否符合规范，验证符号引用是否正常（符号引用后续要转化成直接引用，如果不正常会导致后续的解析过程出错）<br>
  （3）准备：进行初始化，对成员变量进行零值初始化（这就是为何成员变量可以不赋值的情况下直接使用）<br>
  （4）解析：将符号引用转化为直接引用<br>
  （5）初始化：根据程序员的意愿进行初始化（代码级别初始化）<br>
  <h3 id="3.2">3.2必须进行类初始化的几种场景</h3><br>
  （1）new对象，获取静态字段，调用静态方法<br>
  （2）使用反射<br>
  （3）初始化类的时候其父类还没有初始化<br>
  （4）虚拟机启动时，用户指定的执行主类<br>
  <h3 id="3.3">3.3判断类是否是无用类的条件</h3><br>
  （1）该类的所有对象是否已经被回收<br>
  （2）加载该类的加载器是否已经被销毁<br>
  （3）代表该类的java.lang.class对象是否已经被回收<br>
  <h3 id="3.4">3.4类加载器</h3><br>
  （1）启动类加载器：<br>
  （2）扩展类加载器：<br>
  （3）应用程序加载器<br>
  <h3 id="3.5">3.5双亲委派模型</h3><br>
  加载器进行类的加载的时候，会委托上层加载器进行加载。使用双亲委派模型的好处在于程序的稳定。同一个类的可比较前提是同一个加载器加载出来的才具备比较的条件。另外，程序员是可以自定义加载器的，如果不是双亲委派模型，那么程序员就可以加载出自己的java.lang.Object类或者是Stirng类，这样子就乱套了。
